

    <h3 style="text-align: center">Historical Province Boundaries</h3>

    <div id="maptab">
            <form style="text-align:center; font-weight:bold;" action="/explore/" method="get">

            {{ searchform.country.label }} {{ searchform.country }}
            {{ searchform.name.label }} {{ searchform.name }}

            <script>
            submitsearch = function() {
                    document.getElementById("searchbutton").click();
                }
            </script>
            
            <div style="padding:10px; display:inline-block;">
            <input id="searchbutton" type="submit" value="Search" style="background-color:orange; color:white; border-radius:10px; padding:7px; font-family:inherit; font-size:inherit; font-weight:bold; text-decoration:underline; margin:7px;">
            </div>

            </form>

	<div class="map header" style="text-align:center; margin-top: 0; padding: 0 0 0 0;">
            <input id="datetext" type="text" style="text-align:center; font-size:large; font-weight:bold; position:relative; z-index:1000; bottom:-40px; border: 3px solid black; border-radius: 7px;" oninput="update_slider(document.getElementById('datetext').value);"/>
	</div>

	<div id="mapcontainer" style="width:90%; margin-left:5%; height:60vh; padding:0 0 30px 0;">
            <div style="width:100%; height:100%; margins:auto; background-color:rgb(141,168,198);" id="map">
            </div>
	</div>

	<style>
            input[type=range] {
              -webkit-appearance: none;
              width: 100%;
              margin: 5.8px 0;
            }
            input[type=range]:focus {
              outline: none;
            }
            input[type=range]::-webkit-slider-runnable-track {
              width: 100%;
              height: 8.4px;
              cursor: pointer;
              box-shadow: 1px 1px 1px #000000, 0px 0px 1px #0d0d0d;
              background: rgb(200,200,200);
              border-radius: 1.3px;
              border: 0.2px solid #010101;
            }
            input[type=range]::-webkit-slider-thumb {
              box-shadow: 1px 1px 1px #000000, 0px 0px 1px #0d0d0d;
              border: 2.2px solid #000000;
              height: 20px;
              width: 50px;
              border-radius: 3px;
              background: #ffffff;
              cursor: pointer;
              -webkit-appearance: none;
              margin-top: -6px;
            }
            input[type=range]:focus::-webkit-slider-runnable-track {
              background: rgb(200,200,200);
            }
            input[type=range]::-moz-range-track {
              width: 100%;
              height: 8.4px;
              cursor: pointer;
              box-shadow: 1px 1px 1px #000000, 0px 0px 1px #0d0d0d;
              background: #6f6f6f;
              border-radius: 1.3px;
              border: 0.2px solid #010101;
            }
            input[type=range]::-moz-range-thumb {
              box-shadow: 1px 1px 1px #000000, 0px 0px 1px #0d0d0d;
              border: 2.2px solid #000000;
              height: 20px;
              width: 50px;
              border-radius: 3px;
              background: #ffffff;
              cursor: pointer;
            }
            input[type=range]::-ms-track {
              width: 100%;
              height: 8.4px;
              cursor: pointer;
              background: transparent;
              border-color: transparent;
              color: transparent;
            }
            input[type=range]::-ms-fill-lower {
              background: #626262;
              border: 0.2px solid #010101;
              border-radius: 2.6px;
              box-shadow: 1px 1px 1px #000000, 0px 0px 1px #0d0d0d;
            }
            input[type=range]::-ms-fill-upper {
              background: #6f6f6f;
              border: 0.2px solid #010101;
              border-radius: 2.6px;
              box-shadow: 1px 1px 1px #000000, 0px 0px 1px #0d0d0d;
            }
            input[type=range]::-ms-thumb {
              box-shadow: 1px 1px 1px #000000, 0px 0px 1px #0d0d0d;
              border: 2.2px solid #000000;
              height: 20px;
              width: 50px;
              border-radius: 3px;
              background: #ffffff;
              cursor: pointer;
              height: 8.4px;
            }
            input[type=range]:focus::-ms-fill-lower {
              background: #6f6f6f;
            }
            input[type=range]:focus::-ms-fill-upper {
              background: #7c7c7c;
            }
	</style>

	<script>
	var dates = {{ dates|safe }};
	mindate = new Date(dates[0]);
	maxdate = new Date(dates[dates.length-1]);
	function update_slider(date) {
                loaddata();
		// move slider
		curdate = new Date(date);
		var daterange = maxdate.getTime() - mindate.getTime();
		var fraction = (curdate.getTime() - mindate.getTime()) / daterange;
		slider = document.getElementById('dateslider');
		slider.value = fraction;
	};
	</script>
	
	<div style="width:100%; text-align:center;">		
		<p style="font-weight:bold;">
		<a id="sliderStartLabel">{{ dates.0 }}</a>
		<input id="dateslider" type="range" style="width:70%; background-color:black" value="1" min="0" max="1" step="0.0000001" oninput="updatedate(this.value)" onchange="loaddata();"/>
		<a id="sliderEndLabel">{{ dates|last }}</a>
		</p>
	</div>
	
	<script>
	function updatedate(fraction) {
		var daterange = maxdate.getTime() - mindate.getTime();
		var newdate = new Date(mindate.getTime() + (daterange * fraction) );
		datetext = document.getElementById("datetext");
		datetext.value = newdate.toISOString().slice(0,10);
	};
	updatedate(1); // max at default
	</script>
	
	
	
	
	<script src="http://openlayers.org/api/2.13/OpenLayers.js"></script>
	
	<script defer="defer">
	var map = new OpenLayers.Map('map', {resolutions: [0.75,0.55,0.35,0.25,0.17,0.12,0.08,0.06,0.04,0.02,0.01,0.005,0.0025,0.0012,0.0006,0.0003],
                                             allOverlays: true,
                                             });

	// background country layer
	var style = new OpenLayers.Style({fillColor:"rgb(244,244,244)", strokeWidth:0.4, strokeColor:'rgb(177,177,177)'},
					);
	var countryLayer = new OpenLayers.Layer.Vector("Provinces", {styleMap:style});
	map.addLayers([countryLayer]);
        rendercountries = function(data) {
		var geojson_format = new OpenLayers.Format.GeoJSON();
		var geoj_str = JSON.stringify(data);
		countries = geojson_format.read(geoj_str, "FeatureCollection");
		
		feats = [];
		for (feat of countries) {
                        feats.push(feat);
		};
		map.zoomToExtent([-170,70,180,-40]);
		//map.zoomToExtent([-150,70,150,-70]);
		//map.zoomToExtent([-80,30,80,-30]);
		countryLayer.addFeatures(feats);
	};
        $.getJSON('https://raw.githubusercontent.com/johan/world.geo.json/master/countries.geo.json', {}, rendercountries);

	map.zoomToMaxExtent();
	</script>

	<script>

	// empty province layer
	var style = new OpenLayers.Style({fillColor:"${getColor}", fillOpacity:0.5, strokeWidth:0.4},
										{context: {
												getColor: function(feature) {
													return document.countryColors[feature.attributes.country];
												},
											}
										});
	var provLayer = new OpenLayers.Layer.Vector("Provinces", {styleMap:style});
	map.addLayers([provLayer]);

	// province centers
	var provLabelStyle = new OpenLayers.Style({fillOpacity:0, fontSize:"${getFontSize}", label:"${getLabel}"},
										{context: {
												getLabel: function(feature) {
													if (map.resolution < 0.04) {
														return feature.attributes.name.toUpperCase();
													} else if (map.resolution < 0.08) {
														return feature.attributes.name.substring(0,4).toUpperCase();
                                                                                                        } else {
														return '';
													}},
                                                                                                getFontSize: function(feature) {
													if (map.resolution < 0.04) {
														return 11;
													} else if (map.resolution < 0.08) {
														return 6;
                                                                                                        } else {
														return '';
													}}
												}})
	var provLabelLayer = new OpenLayers.Layer.Vector("ProvinceCenters", {styleMap:provLabelStyle});
	map.addLayers([provLabelLayer]);

        function getMaxPoly(polys) {
              // https://stackoverflow.com/questions/37306548/how-to-show-one-label-per-multi-polygon-in-open-layers-3
              var polyObj = [];
              //now need to find which one is the greater and so label only this
              for (var b = 0; b < polys.length; b++) {
                polyObj.push({ poly: polys[b], area: polys[b].getArea() });
              };
              polyObj.sort(function (a, b) { return a.area - b.area });

              return polyObj[polyObj.length - 1].poly;
        }

	label_provs = function() {
            // drop previous
            provLabelLayer.removeAllFeatures();

            if (map.zoom > 3) {
            
                // calc bbox for each
                var feats = [];
                for (feat of document.allProvs) {
                    if (!feat.geometry) {
                        continue;
                    };
                    
                    if (feat.geometry.components.length == 1) {
                        var labpoint = feat.geometry.getCentroid();
                    } else {
                        var labpoint = getMaxPoly(feat.geometry.components).getCentroid();
                    };
                    var feat = new OpenLayers.Feature.Vector(labpoint,
                                                             feat.attributes);
                    feats.push(feat);
                };
                provLabelLayer.addFeatures(feats);

            };
        };
	
	// how to render data
	renderdata = function(data) {
		var geojson_format = new OpenLayers.Format.GeoJSON();
		var geoj_str = JSON.stringify(data);
		document.allProvs = geojson_format.read(geoj_str, "FeatureCollection");
		var date = document.getElementById('datetext').value;
		draw_borders(date);
                label_countries();
                label_provs();
	};

	// country centers
	var countryLabelStyle = new OpenLayers.Style({fillOpacity:0, strokeWidth:0,
                                               fontColor:'white', labelOutlineColor:'black', labelOutlineWidth:2,
                                               fontSize:"${getFontSize}", label:"${getLabel}"}, 
                                                {context: {
                                                                getLabel: function(feature) {
                                                                        return feature.attributes.country.toUpperCase();
                                                                        },
                                                                getFontSize: function(feature) {
                                                                        if (map.resolution < 0.06) {
                                                                            return 19;
                                                                        } else if (map.resolution < 0.12) {
                                                                            return 10;
                                                                        } else if (map.resolution < 0.25) {
                                                                            return 4;
                                                                        } else {
                                                                            return 0.01;
                                                                        }
                                                                },
                                                            },
                                                })
	
	var cntrLayer = new OpenLayers.Layer.Vector("CountryCenters", {styleMap:countryLabelStyle});
	map.addLayers([cntrLayer]);
	
	label_countries = function() {
            // drop previous
            cntrLayer.removeAllFeatures();
            
            // calc bbox for each country
            var cntrBox = {};
            for (feat of document.allProvs) {
                bounds = feat.geometry.getBounds();
                if (!bounds) { continue; }
                if ( !(feat.attributes.country in cntrBox)) {
                    cntrBox[feat.attributes.country] = bounds;
                } else {
                    cntrBox[feat.attributes.country].extend(bounds);
                };
            };

            // add to layer
            var feats = [];
            for (cntr of Object.keys(cntrBox)) {
                var bounds = cntrBox[cntr];
                var feat = new OpenLayers.Feature.Vector(bounds.toGeometry(),
                                                     {country:cntr});
                feats.push(feat);
            };
	    cntrLayer.addFeatures(feats);
        };

	// initiate map
	onstartup = function(data) {
		var geojson_format = new OpenLayers.Format.GeoJSON();
		var geoj_str = JSON.stringify(data);
		document.allProvs = geojson_format.read(geoj_str, "FeatureCollection");
		var date = document.getElementById('datetext').value;
                draw_borders(date);
                label_countries();
                label_provs();
                //map.zoomToExtent(provLayer.getDataExtent());
        };
        var date = document.getElementById('datetext').value;
        var year = date.split("-")[0]
        var month = date.split("-")[1]
        var day = date.split("-")[2]
        var datadict = Object.assign({}, {format:"json", simplify:0.2, year:year, month:month, day:day}, {{ getparams|safe }});
	$.getJSON("/api/", datadict, onstartup);

	// load data func
	function loaddata() {
                // load data with resolution based on zoomlevel
                var date = document.getElementById('datetext').value;
                var year = date.split("-")[0]
                var month = date.split("-")[1]
                var day = date.split("-")[2]

                var bbox = map.getExtent().toArray();

                var apiurl = "/api/";
                var datadict = Object.assign({}, {format:"json", bbox:bbox.join(','), year:year, month:month, day:day}, {{ getparams|safe }});
                //alert(map.resolution);
                if (map.resolution >= 0.17) {
                    datadict['simplify'] = 0.2;
                    $.getJSON(apiurl, datadict, renderdata);
                } else if (map.resolution >= 0.08) {
                    datadict['simplify'] = 0.1;
                    $.getJSON(apiurl, datadict, renderdata);
                } else if (map.resolution >= 0.04) {
                    datadict['simplify'] = 0.05;
                    $.getJSON(apiurl, datadict, renderdata);
                } else if (map.resolution >= 0.02) {
                    datadict['simplify'] = 0.025;
                    $.getJSON(apiurl, datadict, renderdata);
                } else {
                    $.getJSON(apiurl, datadict, renderdata);
                };
        };
	map.events.register("zoomend", map, loaddata);
	map.events.register("moveend", map, loaddata);

        // assign random colors to each country
        document.countryColors = {};
        
        function getRandomColor(){
                var color =  "#" + (Math.random() * 0xFFFFFF << 0).toString(16);
                return color;
        };

	// define drawing function
	function draw_borders(date) {
	
		// drop previous provs
		provLayer.removeAllFeatures();
		
		// select provs by date
		dateFeats = [];
		for (feat of document.allProvs) {
                        if ( ! (feat.attributes.country in document.countryColors)) {
                                // assign random color for country
                                document.countryColors[feat.attributes.country] = getRandomColor();
                        };
                        dateFeats.push(feat);
		};
		
		// add to layer
		provLayer.addFeatures(dateFeats);
	};
	
	</script>

    </div>
